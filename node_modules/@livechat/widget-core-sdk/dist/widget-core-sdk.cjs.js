'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var mitt = _interopDefault(require('@livechat/mitt'));
var es5 = require('@livechat/postmessage/es5');

// eslint-disable-next-line @typescript-eslint/ban-types
var withAmplitude = function withAmplitude(widget) {
  return Object.assign({}, widget, {
    trackEvent: function trackEvent(name, properties) {
      if (typeof name !== 'string' || typeof properties !== 'object') {
        throw new Error('You have to specify the event name and its properties');
      }
      return widget.sendMessage('track', {
        event_name: name,
        event_properties: properties
      });
    }
  });
};

/**
 * Domain allowed to communicate via iframe with Agent App SDK.
 */
var ALLOWED_DOMAINS = ['livechatinc.com', 'livechat.com', 'my.lc:3000', 'legacy.lc:3001'];
/**
 * Returns `true`, if origin is allowed to communicate with Agent App SDK.
 * @param {string} origin Origin of `message` event targetting Agent App SDK.
 * @
 */
function getIsEventOriginAllowed(origin) {
  if (!origin) {
    return false;
  }
  try {
    var originURL = new URL(origin);
    var originDomain = originURL.hostname;
    var splitted = originDomain.split('.');
    var domainOnly = splitted.slice(splitted.length - 2).join('.');
    // As .lc domain is registerable we restrict our development environment
    // based on port usage.
    var toBeVerified = originURL.port ? domainOnly + ":" + originURL.port : domainOnly;
    return ALLOWED_DOMAINS.includes(toBeVerified);
  } catch (_a) {
    return false;
  }
}

function Plain() {
  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
  var currentListener = function currentListener(_) {};
  function handleEvent(event) {
    var isEventOrignAllowed = getIsEventOriginAllowed(event.origin);
    if (isEventOrignAllowed) {
      currentListener(event.data);
    }
  }
  window.addEventListener('message', handleEvent);
  return {
    listen: function listen(listener) {
      currentListener = listener;
    },
    send: function send(message) {
      parent.postMessage(message, '*');
      return Promise.resolve();
    }
  };
}
function Trusted() {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function
  var currentListener = function currentListener(_) {};
  function handleMessage(message) {
    currentListener(message);
  }
  return es5.connectToParent({
    handle: handleMessage
  }).promise.then(function (child) {
    return {
      listen: function listen(listener) {
        currentListener = listener;
      },
      send: function send(message) {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        return child.call('handle', message).then(function () {});
      }
    };
  });
}

function getQueryParams() {
  return location.search.replace(/^\?/, '').split('&').map(function (pair) {
    return pair.split('=').map(decodeURIComponent);
  }).reduce(function (params, _ref) {
    var param = _ref[0],
      value = _ref[1];
    params[param] = value;
    return params;
  }, {});
}
function getQueryParam(name) {
  var queryParams = getQueryParams();
  return queryParams[name] !== undefined ? queryParams[name] : null;
}

var PLUGIN_ID_PARAM = 'plugin_id';
var CONNECTION_PARAM = 'connection';
var MESSAGE_PREFIX = 'livechat:';
function Connection(driver, pluginId) {
  var emitter = mitt();
  function handleMessage(message) {
    if (!message || !message.event_name) {
      return;
    }
    var messageName = message.event_name.toString();
    var messageData = message.event_data;
    if (messageName.startsWith(MESSAGE_PREFIX)) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      emitter.emit(messageName.replace(MESSAGE_PREFIX, ''), messageData);
    }
  }
  driver.listen(handleMessage);
  return {
    emitter: emitter,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sendMessage: function sendMessage(name, data) {
      if (data === void 0) {
        data = null;
      }
      return driver.send({
        plugin_id: pluginId,
        message: name,
        data: data
      });
    }
  };
}
function createConnection() {
  var pluginId = getQueryParam(PLUGIN_ID_PARAM);
  var usePlainConnection = getQueryParam(CONNECTION_PARAM) === 'plain';
  var driverPromise = usePlainConnection ? Promise.resolve(Plain()) : Trusted();
  return driverPromise.then(function (driver) {
    return Connection(driver, pluginId);
  });
}

var ChargeType;
(function (ChargeType) {
  ChargeType["DirectCharge"] = "direct_charge";
  ChargeType["RecurrentCharge"] = "recurrent_charge";
})(ChargeType || (ChargeType = {}));
var OutgoingTransactionEvents;
(function (OutgoingTransactionEvents) {
  OutgoingTransactionEvents["RegisterTransactionPending"] = "register_transaction_pending";
  OutgoingTransactionEvents["RegisterTransactionSuccess"] = "register_transaction_success";
  OutgoingTransactionEvents["RegisterTransactionFailure"] = "register_transaction_failure";
})(OutgoingTransactionEvents || (OutgoingTransactionEvents = {}));
var getChargeType = function getChargeType(charge) {
  return charge.months !== undefined ? ChargeType.RecurrentCharge : ChargeType.DirectCharge;
};
var createPaymentIntent = function createPaymentIntent(charge, metadata) {
  var type = getChargeType(charge);
  var base = {
    name: charge.name,
    price: charge.price,
    per_account: charge.per_account,
    test: charge.test,
    return_url: null,
    metadata: {
      type: type,
      isExternalTransaction: true,
      icon: metadata.icon,
      description: metadata.description,
      showBillingCyclePicker: metadata.showBillingCyclePicker
    }
  };
  return type === ChargeType.RecurrentCharge ? Object.assign({}, base, {
    months: charge.months,
    trial_days: charge.trial_days
  }) : Object.assign({}, base, {
    quantity: charge.quantity
  });
};
var withPayments = function withPayments(widget) {
  return Object.assign({}, widget, {
    startTransaction: function startTransaction(charge, metadata) {
      try {
        if (!charge) {
          throw new Error('You have to provide charge details');
        }
        if (!metadata || !metadata.icon) {
          throw new Error('You have to provide metadata with icon');
        }
        // Process the charge to ensure compatibility with OneClickPayment flow
        var paymentIntent = createPaymentIntent(charge, metadata);
        // Dispatch events to be handled by the OneClickPayment provider
        widget.sendMessage(OutgoingTransactionEvents.RegisterTransactionPending, {
          paymentIntent: paymentIntent
        });
        widget.sendMessage(OutgoingTransactionEvents.RegisterTransactionSuccess, {
          charge: charge
        });
      } catch (error) {
        widget.sendMessage(OutgoingTransactionEvents.RegisterTransactionFailure, {
          error: error
        });
        throw error;
      }
    }
  });
};

function createWidget(connection, api) {
  return Object.assign({}, api, {
    on: connection.emitter.on,
    off: connection.emitter.off,
    sendMessage: function sendMessage(name, data) {
      if (data === void 0) {
        data = null;
      }
      return connection.sendMessage(name, data);
    }
  });
}

exports.createConnection = createConnection;
exports.createWidget = createWidget;
exports.withAmplitude = withAmplitude;
exports.withPayments = withPayments;
